# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'main.py'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import os
import cv2
import sys  #
from pathlib import Path
from PyQt5.QtWidgets import *
from PyQt5.QtGui import QPixmap
from PyQt5.QtCore import QThread, pyqtSignal, Qt

import mesh.frame2, mesh.paraSet, mesh.dense, mesh.reconstructionParam, mesh.video_pre_process, mesh.dense_reconstruction_ui, mesh.dense_reconstruction_ui2, mesh.dense_reconstruction_ui3
import mesh.subSample
import mesh.removal
import mesh.normals
from mesh.read_write_model import read_model, write_model, read_cameras_text, read_images_text, read_points3D_text, write_cameras_text, write_images_text, write_points3D_text
from mesh.visual_model import Model
import subprocess
from PyQt5.QtCore import QProcess
from functools import partial


class UI_Frame(QMainWindow, mesh.frame2.Ui_MainWindow):
    def __init__(self):
        super().__init__()
        self.setupUi(self)

        self.process = QProcess()
        self.process.readyReadStandardOutput.connect(self.update_log)
        # self.process.readyReadStandardOutput.connect(self.onReadyReadStandardOutput)
        Reconstruction_model_path = None

        # self.fileButton.clicked.connect(self.showDialog)  # frame.py
        self.locateSparse_5.clicked.connect(self.showDialog)  # Select dataset path
        self.locateSparse.clicked.connect(self.runOperation)

        self.dense.clicked.connect(self.runOperation_dense)
        # self.dense_9.clicked.connect(self.runOperation_import_3DReconstructionFigure_logs)
        # self.dense_9.clicked.connect(self.run_fast_3DReconstruction(self.openParameterSettings))
        self.parameterSettings1 = UI_para()

        # self.dense_7.clicked.connect(self.run_import_model_fusion)
        self.dense_7.clicked.connect(self.run_import_model)
        self.dense_4.clicked.connect(self.run_export_model)
        self.dense_2.clicked.connect(self.saveLogToFile)
        # self.dense_2.clicked.connect(self.runOperation_para)  # Windows
        self.dense_3.clicked.connect(self.clearLog)
        # Video pre-processing
        self.locateSparse_3.clicked.connect(self.Video_pre_process_UI)

        self.locateSparse_2.clicked.connect(self.openParameterSettings)
        self.dense_5.clicked.connect(self.openModelParameterWindow)
        self.dense_9.clicked.connect(lambda: self.run_fast_3DReconstruction(self.parameterSettings1.result_label,
                                                                            self.parameterSettings1.confValue,
                                                                            self.parameterSettings1.nmsValue,
                                                                            self.parameterSettings1.nnValue,
                                                                            self.parameterSettings1.sampleValue,
                                                                            self.parameterSettings1.result_label_camera))
        self.locateSparse.clicked.connect(self.camera_calibration)

        # Dense reconstruction
        self.dense_8.clicked.connect(self.DenseReconstruction)

    def DenseReconstruction(self):
        self.ui_dense = UI_dense_reconstruction()
        self.ui_dense.show()

    def camera_calibration(self):
        # 调用MATLAB可执行文件的路径
        matlab_path = "\\MATLAB2018a\\bin\\win64\\MATLAB.exe"  # 请根据你的安装路径进行修改

        try:
            subprocess.Popen(matlab_path)
        except FileNotFoundError:
            print("MATLAB executable not found. Please check the path.")

    def openParameterSettings(self):
        self.parameterSettings = UI_para()
        self.parameterSettings.show()

    def Video_pre_processc_UI(self):
        Dataset_path = self.textEdit_3.toPlainText()
        self.Video_pre_process_UI = Video_pre_process_UI(Dataset_path)
        self.Video_pre_process_UI.show()

    def Video_pre_process(self):
        if monocular:
            # 视频文件路径
            video_path = self.textEdit_3.toPlainText()

            # 图片保存目录
            output_root_dir = video_path

            # 遍历video_path目录中的所有MP4文件
            for video_file in os.listdir(video_path):
                if video_file.endswith(".mp4"):
                    # 视频文件完整路径
                    video_file_path = os.path.join(video_path, video_file)

                    # 图片保存目录（以视频文件名命名的文件夹，不包括扩展名）
                    video_output_dir = os.path.join(output_root_dir, os.path.splitext(video_file)[0])
                    os.makedirs(video_output_dir, exist_ok=True)

                    # 打开视频文件
                    cap = cv2.VideoCapture(video_file_path)

                    # 获取视频的帧率
                    fps = int(cap.get(cv2.CAP_PROP_FPS))

                    # 用于计数的变量
                    frame_count = 0

                    # 循环读取视频帧
                    while True:
                        ret, frame = cap.read()
                        if not ret:
                            break
                        # 保存帧为图像文件
                        image_filename = os.path.join(video_output_dir, f"frame_{frame_count:04d}.png")
                        cv2.imwrite(image_filename, frame)
                        # 打印已保存的帧数
                        print(f"Saved {image_filename}")
                        frame_count += 1

                    # 释放视频捕获对象
                    cap.release()
                    print(f"Video to images conversion complete for {video_file_path}.")

        if binocular_camera:
            i = 0
            img_path = video_path
            img_path2 = os.path.join(video_path, "img_binocular/left/")
            img_path3 = os.path.join(video_path, "img_binocular/right/")
            for filename in os.listdir(img_path):
                image = cv2.imread(os.path.join(img_path, filename))
                left = image[:, 0:image.shape[0]]
                right = image[:, image.shape[0]:]
                pathl = osp.join(img_path2, "img_{:0>5}.png".format(i))
                cv2.imwrite(pathl, left)
                pathr = osp.join(img_path3, "img_{:0>5}.png".format(i))
                cv2.imwrite(pathr, right)
                i = i + 1

    def openModelParameterWindow(self):
        self.ui_reconstructionParam = UI_reconstructionParam()
        self.ui_reconstructionParam.show()

    def saveLogToFile(self):
        options = QFileDialog.Options()
        options |= QFileDialog.DontUseNativeDialog
        file_path, _ = QFileDialog.getSaveFileName(self, "Save Log File", "",
                                                   "Text Files (*.txt);;All Files (*)", options=options)
        if file_path:
            with open(file_path, 'w') as f:
                f.write(self.log.toPlainText())

    def clearLog(self):
        self.log.clear()

    def update_log(self):
        data = self.process.readAllStandardOutput().data().decode()
        self.log.appendPlainText(data)# Append the message to the textEdit

    def show_log(self):
        data = self.process.readAllStandardOutput().data().decode()
        self.log.appendPlainText(data)# Append the message to the textEdit

    def run_fast_3DReconstruction(self, result_detector_label, confValue, nmsValue, nnValue, sampleValue, result_label_camera):
        Save_folder_path = QFileDialog.getExistingDirectory(self, 'Select the path to save the experiment results')

        # Point 3D Reconstruction
        if self.checkBox.isChecked() and not self.checkBox_2.isChecked():
            cmd = "python point_reconstruction.py"
            Dataset_path = self.textEdit_3.toPlainText()
            proj_path = "--projpath" + " " + Dataset_path
            cameraModel = "--cameraModel" + " " + result_label_camera.text()
            images_path = "--images_path images"
            single_camera = "--single_camera"
            model_name = "--model_name checkpoint_point_model"
            conf_thresh = "--conf_thresh" + " " + str(confValue.value())
            nms_dist = "--nms_dist" + " " + str(nmsValue.value())
            nn_thresh = "--nn_thresh" + " " + str(nnValue.value())

            cmd += " " + proj_path + " " + cameraModel + " " + images_path + " " + single_camera + " " + model_name + " " + conf_thresh + " " + nms_dist + " " + nn_thresh
            os.chdir("/home/pointReconstruction")  # Change to the specified directory
            self.process.start(cmd)

            # Wait for the first process to finish
            self.process.waitForFinished()

            # Running the second command after finishing the first command
            Save_folder_path = os.path.join(Dataset_path, "checkpoint_point_model/sparse/0")
            self.process.finished.connect(partial(self.onProcessVisualize3DPoints, Save_folder_path))

        # Line 3D Reconstruction
        if self.checkBox_2.isChecked() and not self.checkBox.isChecked():
            cmd = "python line_reconstruction.py"
            config_file_path = "--config_file cfgs/line_reconstruction.yaml"
            default_config_file_path = "--default_config_file cfgs/default_line_reconstruction.yaml"
            Dataset_path = self.textEdit_3.toPlainText()
            colmap_path = "--colmap_path" + " " + Dataset_path
            output_dir = "--output_dir" + " " + Save_folder_path
            cmd += " " + config_file_path + " " + default_config_file_path + " " + colmap_path + " " + output_dir
            os.chdir("/home/lineReconstruction")  # Change to the specified directory
            self.process.start(cmd)

            # Wait for the first process to finish
            self.process.waitForFinished()

            # Running the second command after finishing the first command
            self.process.finished.connect(partial(self.onProcessVisualize3DLines, Save_folder_path))

        # Point-Line 3D Reconstruction
        if self.checkBox.isChecked() and self.checkBox_2.isChecked():
            cmd = "python points_lines_reconstruction.py"
            input_line_dir = "--input_dir" + " " + os.path.join(folder_path, "finaltracks")
            imagecols_dir = "--imagecols" + " " + os.path.join(folder_path, "imagecols.npy")
            input_model_path = "--input_model" + " " + os.path.join(folder_path, "sparse")
            ############################# Revise the way of save images #######################
            save_img_name = "--save_img_name TESTS"
            cmd += " " + input_line_dir + " " + imagecols_dir + " " + input_model_path + " " + save_img_name
            os.chdir("/home/point_line_reconstruction/")  # Change to the specified directory
            subprocess.Popen(cmd, shell=True)

    def onProcessVisualize3DPoints(self, folder_path):
        cmd2 = "python visualize_model.py"
        input_model_path = "--input_model" + " " + folder_path
        cmd2 += " " + input_model_path
        os.chdir("/home/pointReconstruction/")  # Change to the specified directory
        self.process2 = QProcess()
        self.process2.start(cmd2)

        # You can connect finished signal for the second process to another slot if needed
        self.process2.finished.connect(self.onProcess2Finished)

    def onProcess2Finished(self):
        # Second process finished
        print("Second process finished")

    def onProcessVisualize3DLines(self, folder_path):
        cmd = "python visualize_3d_lines.py"
        input_line_dir = "--input_dir" + " " + os.path.join(folder_path, "finaltracks")
        imagecols_dir = "--imagecols" + " " + os.path.join(folder_path, "imagecols.npy")
        cmd += " " + input_line_dir + " " + imagecols_dir
        subprocess.Popen(cmd, shell=True)

    def onProcessVisualize3DPointsLine(self, folder_path):
        cmd = "python visual_3d_points_lines.py"
        input_line_dir = "--input_dir" + " " + os.path.join(folder_path, "finaltracks")
        imagecols_dir = "--imagecols" + " " + os.path.join(folder_path, "imagecols.npy")
        input_model_path = "--input_model" + " " + os.path.join(folder_path, "tmp_point/sparse")
        ############################# Revise the way of save images #######################
        save_img_name = "--save_img_name TESTS"
        cmd += " " + input_line_dir + " " + imagecols_dir + " " + input_model_path + " " + save_img_name
        subprocess.Popen(cmd, shell=True)

    def showDialog(self):
        folder_path = QFileDialog.getExistingDirectory(self, 'Select dataset path')
        if folder_path:
            self.textEdit_3.setPlainText(folder_path)
            # self.filePath.setPlainText(folder_path)  # frame.py

    def runOperation(self):
        file_path, _ = QFileDialog.getOpenFileName(self, 'Open Image File', '',
                                                   'Images (*.png *.jpg *.bmp *.gif);;All Files (*)')
        if file_path:
            pixmap = QPixmap(file_path)
            # 设置图片大小
            resized_pixmap = pixmap.scaled(560, 350, aspectRatioMode=0)
            self.label.setPixmap(resized_pixmap)
            self.label.show()

    def run_export_model(self):
        Reconstruction_model_path = None
        ext = ".bin"
        path_str = self.textEdit_4.toPlainText()
        pathdir_import = Path(path_str)

        if Reconstruction_model_path is None:
            if ext == ".txt":
                cameras_txt, images_txt, points3D_txt = read_model(pathdir_import, ext=".txt")
            else:
                cameras_bin, images_bin, points3D_bin = read_model(pathdir_import, ext=".bin")
            pathdir_export = QFileDialog.getExistingDirectory(self, 'Select export model save path')
            if ext == ".txt":
                write_model(cameras_txt, images_txt, points3D_txt, pathdir_export, ext=".txt")
            else:
                write_model(cameras_bin, images_bin, points3D_bin, pathdir_export, ext=".bin")
            # return cameras, images, points3D

    def run_import_model(self):
        # Select point model
        if not self.checkBox_3.isChecked() and not self.checkBox_4.isChecked():
            self.show_import_model_prompt_message()
        else:
            folder_path = QFileDialog.getExistingDirectory(self, 'Select import model path')

        # Select point model
        if self.checkBox_3.isChecked() and not self.checkBox_4.isChecked():
            cmd = "python visualize_model.py"
            input_model_path = "--input_model" + " " + os.path.join(folder_path, "tmp_point/sparse")
            cmd += " " + input_model_path
            os.chdir("/home/pointReconstruction/")  # Change to the specified directory
            subprocess.Popen(cmd, shell=True)

        # Select line model
        if self.checkBox_4.isChecked() and not self.checkBox_3.isChecked():
            cmd = "python visualize_3d_lines.py"
            input_line_dir = "--input_dir" + " " + os.path.join(folder_path, "finaltracks")
            imagecols_dir = "--imagecols" + " " + os.path.join(folder_path, "imagecols.npy")
            cmd += " " + input_line_dir + " " + imagecols_dir
            os.chdir("/home/lineReconstruction/")  # Change to the specified directory
            subprocess.Popen(cmd, shell=True)

        # Select point-line model
        if self.checkBox_3.isChecked() and self.checkBox_4.isChecked():
            cmd = "python visual_3d_points_lines.py"
            input_line_dir = "--input_dir" + " " + os.path.join(folder_path, "finaltracks")
            imagecols_dir = "--imagecols" + " " + os.path.join(folder_path, "imagecols.npy")
            input_model_path = "--input_model" + " " + os.path.join(folder_path, "tmp_point/sparse")
            ############################# Revise the way of save images #######################
            save_img_name = "--save_img_name TESTS"
            cmd += " " + input_line_dir + " " + imagecols_dir + " " + input_model_path + " " + save_img_name
            os.chdir("/home/point_line_reconstruction/")  # Change to the specified directory
            subprocess.Popen(cmd, shell=True)

    def show_import_model_prompt_message(self):
        msg_box = QMessageBox()
        msg_box.setIcon(QMessageBox.Information)
        msg_box.setWindowTitle("导入模型提示")
        msg_box.setText("请选择导入模型类型。")
        msg_box.setStandardButtons(QMessageBox.Ok)
        msg_box.exec_()

    def run_import_model_fusion(self):
        ext = ".bin"  # Set the format of import model
        # read COLMAP model
        model = Model()
        # Select point model
        if self.checkBox_3.isChecked() and not self.checkBox_4.isChecked():
            folder_path = QFileDialog.getExistingDirectory(self, 'Select import point model path')
            if folder_path:
                self.textEdit_4.setPlainText(folder_path)
                Reconstruction_model_path = self.textEdit_4.toPlainText()
            model.read_model(folder_path, ext=ext)
            model.create_window(height=1080, width=1920)
            model.add_points()
            model.add_cameras(scale=0.05)
            model.show()

        # Select line model
        if self.checkBox_4.isChecked() and not self.checkBox_3.isChecked():
            folder_path = QFileDialog.getExistingDirectory(self, 'Select import line model path')
            if folder_path:
                self.textEdit_4.setPlainText(folder_path)
                Reconstruction_model_path = self.textEdit_4.toPlainText()
            model.read_model(folder_path, ext=ext)
            model.create_window(height=1080, width=1920)
            model.add_points()
            model.add_cameras(scale=0.05)
            model.show()

        # Select point-line model
        if self.checkBox_3.isChecked() and self.checkBox_4.isChecked():
            folder_path = QFileDialog.getExistingDirectory(self, 'Select import point-line model path')
            if folder_path:
                self.textEdit_4.setPlainText(folder_path)
                Reconstruction_model_path = self.textEdit_4.toPlainText()
            model.read_model(folder_path, ext=ext)
            model.create_window(height=1080, width=1920)
            model.add_points()
            model.add_cameras(scale=0.05)
            model.show()
        else:
            folder_path = QFileDialog.getExistingDirectory(self, 'Select import point-line model path')
            if folder_path:
                self.textEdit_4.setPlainText(folder_path)
                Reconstruction_model_path = self.textEdit_4.toPlainText()
            model.read_model(folder_path, ext=ext)
            model.create_window(height=1080, width=1920)
            model.add_points()
            model.add_cameras(scale=0.05)
            model.show()
        return Reconstruction_model_path

    def runOperation_dense(self):
        file_path, _ = QFileDialog.getOpenFileName(self, 'Open Image File', '',
                                                   'Images (*.png *.jpg *.bmp *.gif);;All Files (*)')
        if file_path:
            pixmap = QPixmap(file_path)
            self.label_2.setPixmap(pixmap)
            self.label_2.show()

    def runOperation_import_3DReconstructionFigure_logs(self):
        file_path, _ = QFileDialog.getOpenFileName(self, 'Open Image File', '',
                                                   'Images (*.png *.jpg *.bmp *.gif);;All Files (*)')
        if file_path:
            pixmap = QPixmap(file_path)
            # 设置图片大小
            width = self.label.size().width()
            height = self.label.size().height()
            resized_pixmap = pixmap.scaled(width, height, aspectRatioMode=0)
            self.label.setPixmap(resized_pixmap)
            self.label.show()
        # Replace this with your custom operation
        file_path, _ = QFileDialog.getOpenFileName(self, 'Open TXT File', '', 'Text Files (*.txt);;All Files (*)')
        if file_path:
            with open(file_path, 'r') as file:
                file_content = file.read()
                self.log.setPlainText(file_content)

    def runOperation_para(self):
        # Replace this with your custom operation
        file_path, _ = QFileDialog.getOpenFileName(self, 'Open TXT File', '', 'Text Files (*.txt);;All Files (*)')
        if file_path:
            with open(file_path, 'r') as file:
                file_content = file.read()
                self.log.setPlainText(file_content)

class UI_para(QMainWindow, mesh.paraSet.Ui_MainWindow):
    def __init__(self):
        super().__init__()
        self.setupUi(self)

        self.comboBoxDetector.addItem('SuperPoint')
        self.comboBoxDetector.addItem('SIFT')
        self.comboBoxDetector.currentIndexChanged.connect(self.onComboBoxDetectorChange)
        self.result_label = QLabel(self)
        self.result_label.setGeometry(290, 40, 141, 20)  # Set the position and size of the result QLabel
        self.result_label.setText('SuperPoint')  # Set the default value
        self.result_label.hide()  # Hide the label

        self.horizontalSliderConf.setMinimum(0)
        self.horizontalSliderConf.setMaximum(100)
        self.horizontalSliderConf.setSingleStep(0.01)
        self.horizontalSliderConf.setValue(15)
        self.horizontalSliderConf.setTickPosition(QSlider.TicksAbove)
        self.horizontalSliderConf.setTickInterval(10)
        self.horizontalSliderConf.valueChanged.connect(self.ConfValueChange)

        self.confValue.setRange(0.00, 0.1)
        self.confValue.setSingleStep(0.001)
        self.confValue.setDecimals(3)  # Set the number of decimal places
        self.confValue.setValue(0.015)
        self.confValue.valueChanged.connect(self.ConfSliderChange)

        self.horizontalSliderNMS.setRange(0, 10)
        self.horizontalSliderNMS.setSingleStep(0.1)
        self.horizontalSliderNMS.setValue(4)
        self.horizontalSliderNMS.setTickPosition(QSlider.TicksAbove)
        self.horizontalSliderNMS.setTickInterval(1)
        self.horizontalSliderNMS.valueChanged.connect(self.nmsValueChange)

        self.nmsValue.setRange(0, 10)
        self.nmsValue.setValue(4)
        self.nmsValue.valueChanged.connect(self.nmsSliderChange)

        self.horizontalSliderNN.setRange(0, 100)
        self.horizontalSliderNN.setSingleStep(1)
        self.horizontalSliderNN.setValue(70)
        self.horizontalSliderNN.setTickPosition(QSlider.TicksAbove)
        self.horizontalSliderNN.setTickInterval(10)
        self.horizontalSliderNN.valueChanged.connect(self.nnValueChange)

        self.nnValue.setRange(0.00, 1)
        self.nnValue.setDecimals(2)  # Set the number of decimal places
        self.nnValue.setValue(0.7)
        self.nnValue.setSingleStep(0.01)
        self.nnValue.valueChanged.connect(self.nnSliderChange)

        self.horizontalSliderSample.setMinimum(0)
        self.horizontalSliderSample.setMaximum(10000)
        self.horizontalSliderSample.setSingleStep(10)
        self.horizontalSliderSample.setValue(2000)
        self.horizontalSliderSample.setTickPosition(QSlider.TicksAbove)
        self.horizontalSliderSample.setTickInterval(1000)
        self.horizontalSliderSample.valueChanged.connect(self.SampleValueChange)

        self.sampleValue.setMinimum(0)
        self.sampleValue.setMaximum(10000)
        self.sampleValue.setValue(2000)
        self.sampleValue.valueChanged.connect(self.SampleSliderChange)

        self.comboBoxCamera.addItem('SIMPLE_PINHOLE')
        self.comboBoxCamera.addItem('SIMPLE_RADIAL')
        self.comboBoxCamera.addItem('OPENCV')
        self.comboBoxCamera.currentIndexChanged.connect(self.onComboBoxCameraChange)
        self.result_label_camera = QLabel(self)
        self.result_label_camera.setGeometry(303, 380, 141, 20)  # Set the position and size of the result QLabel
        self.result_label_camera.setText('SIMPLE_PINHOLE')  # Set the default value
        self.result_label_camera.hide()  # Hide the label

        # Add save and cancel button
        self.paraSave.clicked.connect(self.save_changes)  # save button
        self.paraReturn.clicked.connect(self.cancel_changes)  # cancel button

        self.checkBoxGpu.setChecked(True)  # Set default is using GPU

    def save_changes(self):
        result_detector_label_text = self.result_label.text()
        config_threshold = self.confValue.value()
        nms_threshold = self.nmsValue.value()
        nn_threshold = self.nnValue.value()
        sample_value = self.sampleValue.value()
        result_label_camera_text = self.result_label_camera.text()

        # Close the window
        self.close()

    def cancel_changes(self):
        # Hold the default value and close the window
        self.result_label.setText('SuperPoint')
        self.confValue.setValue(0.015)
        self.nmsValue.setValue(4)
        self.nnValue.setValue(0.7)
        self.sampleValue.setValue(2000)
        self.result_label_camera.setText('SIMPLE_PINHOLE')
        self.close()

    def onComboBoxDetectorChange(self):
        selected_item = self.sender().currentText()
        self.result_label.setText(f'{selected_item}')
        # self.result_label.setText(f'Selected Item: {selected_item}')

    def ConfValueChange(self):
        confSize = self.horizontalSliderConf.value()
        self.confValue.setValue(confSize / 1000.00)

    def ConfSliderChange(self):
        confSize = self.confValue.value()
        self.horizontalSliderConf.setValue(confSize)

    def nmsValueChange(self):
        nmsSize = self.horizontalSliderNMS.value()
        self.nmsValue.setValue(nmsSize)

    def nmsSliderChange(self):
        nmsValueSize = self.nmsValue.value()
        self.horizontalSliderNMS.setValue(nmsValueSize)

    def nnValueChange(self):
        confSize = self.horizontalSliderNN.value()
        self.nnValue.setValue(confSize / 100)

    def nnSliderChange(self):
        nnValueSize = self.nnValue.value()
        self.horizontalSliderNN.setValue(nnValueSize * 100)

    def SampleValueChange(self):
        SampleSize = self.horizontalSliderSample.value()
        self.sampleValue.setValue(SampleSize)

    def SampleSliderChange(self):
        SampleValueSize = self.sampleValue.value()
        self.horizontalSliderSample.setValue(SampleValueSize)

    def onComboBoxCameraChange(self):
        selected_item = self.sender().currentText()
        self.result_label_camera.setText(f'{selected_item}')
############################################################################################

class Video_pre_process_UI(QMainWindow, mesh.video_pre_process.Ui_Form):
    def __init__(self, Dataset_path):
        super().__init__()
        self.setupUi(self)
        self.dataset_path = Dataset_path

        self.spinBox.setRange(0, 10)
        self.spinBox.setSingleStep(1)
        self.spinBox.setValue(1)
        self.spinBox.valueChanged.connect(self.ConfSliderChange)

        self.horizontalSliderConf.setMinimum(1)
        self.horizontalSliderConf.setMaximum(10)
        self.horizontalSliderConf.setSingleStep(1)
        self.horizontalSliderConf.setValue(1)
        self.horizontalSliderConf.setTickPosition(QSlider.TicksAbove)
        self.horizontalSliderConf.setTickInterval(1)
        self.horizontalSliderConf.valueChanged.connect(self.ConfValueChange)

        # Add video segment and cancel button
        self.pushButton_2.clicked.connect(self.start_segment)  # save button
        self.pushButton.clicked.connect(self.cancel_changes)  # cancel button

    def show_completion_message(self):
        msg_box = QMessageBox()
        msg_box.setIcon(QMessageBox.Information)
        msg_box.setWindowTitle("视频分割完成")
        msg_box.setText("视频分割已完成。")
        msg_box.setStandardButtons(QMessageBox.Ok)
        msg_box.exec_()

    def start_segment(self):
        monocular = self.radioButton.isChecked()
        binocular = self.radioButton_2.isChecked()
        # 间隔帧数
        interval = self.spinBox.value()
        # The path of video
        video_path = self.dataset_path
        if monocular:
            # Save path
            output_root_dir = video_path

            # 遍历video_path目录中的所有MP4文件
            for video_file in os.listdir(video_path):
                if video_file.endswith(".mp4"):
                    # 视频文件完整路径
                    video_file_path = os.path.join(video_path, video_file)

                    # 图片保存目录（以视频文件名命名的文件夹，不包括扩展名）
                    video_output_dir = os.path.join(output_root_dir, os.path.splitext(video_file)[0])
                    os.makedirs(video_output_dir, exist_ok=True)

                    # 打开视频文件
                    cap = cv2.VideoCapture(video_file_path)

                    # 获取视频的帧率
                    fps = int(cap.get(cv2.CAP_PROP_FPS))

                    # 用于计数的变量
                    frame_count = 0
                    saved_frame_count = 0  # 新的计数器用于图像保存

                    # 循环读取视频帧
                    while True:
                        ret, frame = cap.read()
                        if not ret:
                            break
                            # 仅在满足间隔条件时保存帧
                        if frame_count % interval == 0:
                            image_filename = os.path.join(video_path, f"frame_{saved_frame_count:04d}.png")
                            cv2.imwrite(image_filename, frame)
                            # 打印已保存的帧数
                            print(f"Saved {image_filename}")
                            saved_frame_count += 1  # 更新保存计数器
                        frame_count += 1

            # 关闭当前窗口
            self.close()

            # 弹出提示窗口
            self.show_completion_message()

        if binocular:
            # 遍历video_path目录中的所有MP4文件
            for video_file in os.listdir(video_path):
                if video_file.endswith(".mp4"):
                    # 视频文件完整路径
                    video_file_path = os.path.join(video_path, video_file)
                    # 图片保存目录（以视频文件名命名的文件夹，不包括扩展名）
                    img_save_dir_left = os.path.join(video_path, os.path.splitext(video_file)[0], "left")
                    img_save_dir_right = os.path.join(video_path, os.path.splitext(video_file)[0], "right")
                    os.makedirs(img_save_dir_left, exist_ok=True)
                    os.makedirs(img_save_dir_right, exist_ok=True)

                    # 打开视频文件
                    cap = cv2.VideoCapture(video_file_path)

                    # 获取视频的帧率
                    fps = int(cap.get(cv2.CAP_PROP_FPS))

                    # 用于计数的变量
                    frame_count = 0
                    saved_frame_count = 0  # 新的计数器用于图像保存

                    # 循环读取视频帧
                    while True:
                        ret, frame = cap.read()
                        if not ret:
                            break
                            # 仅在满足间隔条件时保存帧
                        if frame_count % interval == 0:
                            left = frame[:, 0:(frame.shape[1]//2)]
                            right = frame[:, (frame.shape[1]//2):]
                            pathl = os.path.join(img_save_dir_left, f"frame_{saved_frame_count:04d}.png")
                            cv2.imwrite(pathl, left)
                            pathr = os.path.join(img_save_dir_right, f"frame_{saved_frame_count:04d}.png")
                            cv2.imwrite(pathr, right)
                            saved_frame_count += 1
                        frame_count += 1

            # 关闭当前窗口
            self.close()
            # 弹出提示窗口
            self.show_completion_message()

    def cancel_changes(self):
        self.close()

    def ConfValueChange(self):
        confSize = self.horizontalSliderConf.value()
        self.spinBox.setValue(confSize)

    def ConfSliderChange(self):
        confSize = self.spinBox.value()
        self.horizontalSliderConf.setValue(confSize)

class UI_dense(QMainWindow, mesh.dense.Ui_MainWindow):
    def __init__(self):
        super().__init__()
        self.setupUi(self)

        self.SaveDataButton.clicked.connect(self.showDialog)
        self.DepthFusionButton.clicked.connect(self.runOperation_dense)

    def showDialog(self):
        folder_path = QFileDialog.getExistingDirectory(self, 'Select Folder')
        if folder_path:
            self.filePath.setPlainText(folder_path)

    def runOperation_dense(self):
        file_path, _ = QFileDialog.getOpenFileName(self, 'Open Image File', '',
                                                   'Images (*.png *.jpg *.bmp *.gif);;All Files (*)')
        if file_path:
            pixmap = QPixmap(file_path)
            # 设置图片大小
            resized_pixmap = pixmap.scaled(640, 400, aspectRatioMode=0)
            self.label.setPixmap(resized_pixmap)
            self.label.show()


class ImageDialog(QDialog):
    def __init__(self, image_path, parent=None):
        super().__init__(parent)
        self.setWindowTitle('Image Viewer')
        self.setGeometry(100, 100, 600, 400)

        self.layout = QVBoxLayout()

        # Create a label to show the image
        self.imageLabel = QLabel()
        self.layout.addWidget(self.imageLabel)

        pixmap = QPixmap(image_path)
        self.imageLabel.setPixmap(pixmap)
        self.imageLabel.setScaledContents(True)

        self.setLayout(self.layout)


class ImageWidget(QWidget):
    def __init__(self, file, directory, main_window, parent=None):
        super().__init__(parent)
        self.filename = file
        self.main_window = main_window
        self.directory = directory
        self.initUI()

    def initUI(self):
        layout = QHBoxLayout()

        # Add a label for the index
        self.indexLabel = QLabel()
        self.label = QLabel(self.filename)
        self.button = QPushButton('Show Image')
        self.mask1Button = QPushButton("Show geometric map")
        self.mask2Button = QPushButton("Show photometric map")
        self.mask3Button = QPushButton("Show final map")

        self.mask1Button.setEnabled(self.checkMaskExists("geo"))
        self.mask2Button.setEnabled(self.checkMaskExists("photo"))
        self.mask3Button.setEnabled(self.checkMaskExists("final"))

        self.button.clicked.connect(self.showImage)
        self.mask1Button.clicked.connect(self.showMask1)
        self.mask2Button.clicked.connect(self.showMask2)
        self.mask3Button.clicked.connect(self.showMask3)

        layout.addWidget(self.indexLabel)
        layout.addWidget(self.label)
        layout.addWidget(self.button)
        layout.addWidget(self.mask1Button)
        layout.addWidget(self.mask2Button)
        layout.addWidget(self.mask3Button)
        self.setLayout(layout)

    def updateIndex(self, index):
        self.indexLabel.setText(f"{index + 1}")  # Adding 1 to convert from 0-based to 1-based index

    def showImage(self):
        self.main_window.showImage(self.filename)

    def showImage_mask(self, imagePath):
        if os.path.exists(imagePath):
            self.dialog = ImageDialog(imagePath)
            self.dialog.exec_()
        else:
            QMessageBox.warning(self, "Warning", f"Image not found: {imagePath}")


    def checkMaskExists(self, mask_suffix):
        # maskPath = os.path.join(self.directory, "dense", self.filename)
        for i in range(66):  # Iterate from 0 to 10 (inclusive)
            filename_no_ext = str(i).zfill(8)
            mask_filename = f"{filename_no_ext}_{mask_suffix}.png"
            maskPath = os.path.join(self.directory, "dense/mask", mask_filename)
        return True
        # return False

    def showMask1(self):
        self.showMask("geo")

    def showMask2(self):
        self.showMask("photo")

    def showMask3(self):
        self.showMask("final")

    def showMask(self, mask_suffix):
        for i in range(66):  # Iterate from 0 to 10 (inclusive)
            filename_no_ext = str(i).zfill(8)
            mask_filename = f"{filename_no_ext}_{mask_suffix}.png"
            maskPath = os.path.join(self.directory, "dense/mask", mask_filename)
        if os.path.exists(maskPath):
            self.showImage_mask(maskPath)
        else:
            QMessageBox.warning(self, "Warning", f"Mask image not found in {mask_filename}")


class CommandThread(QThread):
    finished = pyqtSignal()  # Signal to indicate the command has finished

    def __init__(self, cmd):
        super().__init__()
        self.cmd = cmd

    def run(self):
        subprocess.run(self.cmd, shell=True)
        self.finished.emit()

class UI_dense_reconstruction(QMainWindow, mesh.dense_reconstruction_ui3.Ui_MainWindow):
    def __init__(self):
        super().__init__()
        self.setupUi(self)
        self.listWidget.clicked.connect(self.showImage)

        # Create a button to open data directory
        self.pushButton.clicked.connect(self.openDirectory)

        # Create a path to save result
        self.pushButton_2.clicked.connect(self.showDialog)

        # Convert the data format
        self.pushButton_3.clicked.connect(self.Convert_data_format)

        # Dense reconstruction
        self.pushButton_4.clicked.connect(self.Dense_3D_Reconstruction)

    def Dense_3D_Reconstruction(self):

        cmd = "python eval.py"
        input_data_path = self.textEdit2.toPlainText()
        output_data_path = os.path.join(input_data_path, "dense")
        os.makedirs(output_data_path, exist_ok=True)
        input_folder = "--input_folder" + " " + input_data_path
        output_folder = "--output_folder" + " " + output_data_path
        checkpoint_path = "--checkpoint_path" + " " + "/home//checkpoints/checkpoints.ckpt"
        num_views = "--num_views" + " " + "5"
        image_max_dim = "--image_max_dim" + " " + "1600"
        geo_mask_thres = "--geo_mask_thres" + " " + "3"
        photo_thres = "--photo_thres" + " " + "0.8"
        os.chdir("/home/dense_reconstruction/")  # Change to the specified directory
        cmd += " " + input_folder + " " + output_folder + " " + checkpoint_path + " " + num_views + " " + image_max_dim + " " + geo_mask_thres + " " + photo_thres + " " + "$@"

        self.progress = QProgressDialog("Processing...", "Cancel", 0, 0, self)
        self.progress.setWindowTitle("Please Wait")
        self.progress.setCancelButton(None)
        self.progress.setWindowModality(Qt.WindowModal)
        self.progress.show()

        self.thread = CommandThread(cmd)
        self.thread.finished.connect(self.on_finished_dense_reconstruction)
        self.thread.start()

        '''msg_box = QMessageBox()  # windows
        msg_box.setIcon(QMessageBox.Information)
        msg_box.setWindowTitle("Info")
        msg_box.setText("Dense 3D reconstruction completed.")
        msg_box.setStandardButtons(QMessageBox.Ok)
        msg_box.exec_()'''

    def Convert_data_format(self):
        cmd = "python convert_input.py"

        input_data_path = self.textEdit.toPlainText()
        self.output_data_path = self.textEdit2.toPlainText()
        input_folder = "--input_folder" + " " + input_data_path
        output_folder = "--output_folder" + " " + self.output_data_path
        os.chdir("/home/dense_reconstruction/")  # Change to the specified directory
        cmd += " " + input_folder + " " + output_folder

        self.progress = QProgressDialog("Processing...", "Cancel", 0, 0, self)
        self.progress.setWindowTitle("Please Wait")
        self.progress.setCancelButton(None)
        self.progress.setWindowModality(Qt.WindowModal)
        self.progress.show()

        self.thread = CommandThread(cmd)
        self.thread.finished.connect(self.on_finished)
        self.thread.start()

    def on_finished(self):
        self.progress.close()
        QMessageBox.information(self, "Info", "Data conversion completed.")

    def on_finished_dense_reconstruction(self):
        self.progress.close()
        QMessageBox.information(self, "Info", "Dense 3D reconstruction completed.")


    def showDialog(self):
        folder_path = QFileDialog.getExistingDirectory(self, 'Select Save Path')
        if folder_path:
            self.textEdit2.setPlainText(folder_path)

    def openDirectory(self):
        directory = QFileDialog.getExistingDirectory(self, 'Open Data Directory', '',
                                                     QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks)
        img_directory = os.path.join(directory, "images")
        if img_directory:
            self.listWidget.clear()
            self.imageFiles = [f for f in os.listdir(img_directory) if
                               os.path.isfile(os.path.join(img_directory, f)) and f.lower().endswith(
                                   ('.png', '.jpg', '.jpeg', '.bmp', '.gif'))]
            self.currentDirectory = directory
            path = self.textEdit2.toPlainText()

            # Show the path
            self.textEdit.setPlainText(directory)

            for i, file in enumerate(self.imageFiles):
                item = QListWidgetItem()
                widget = ImageWidget(file, path, self)
                widget.updateIndex(i)  # Update the index label
                item.setSizeHint(widget.sizeHint())
                self.listWidget.addItem(item)
                self.listWidget.setItemWidget(item, widget)

    def showImage(self, file):
        imagePath = os.path.join(self.currentDirectory, "images", file)
        print("imagePath", imagePath)
        self.dialog = ImageDialog(imagePath)
        self.dialog.exec_()


class UI_reconstructionParam(QMainWindow, mesh.
                             reconstructionParam.Ui_MainWindow):
    def __init__(self):
        super().__init__()
        self.setupUi(self)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ui_win = UI_Frame()
    ui_win.show()
    '''ui_para = UI_para()
    ui_para.show()
    ui_dense = UI_dense()
    ui_dense.show()
    ui_reconstructionParam = UI_reconstructionParam()
    ui_reconstructionParam.show()'''
    sys.exit(app.exec_())
